<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux/System on 梦还在吗</title>
    <link>http://example.org/tags/linux/system/</link>
    <description>Recent content in Linux/System on 梦还在吗</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="http://example.org/tags/linux/system/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>计划任务crontab</title>
      <link>http://example.org/posts/%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1crontab/</link>
      <pubDate>Wed, 13 May 2020 17:13:23 +0000</pubDate>
      
      <guid>http://example.org/posts/%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1crontab/</guid>
      <description>计划任务crontab crontab 命令从输入设备读取指令，并将其存放于 crontab 文件中，以供之后读取和执行。通常，crontab 储存的指令被守护进程激活，crond 为其守护进程，crond 常常在后台运行，每一分钟会检查一次是否有预定的作业需要执行。
通过 crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script 脚本。时间间隔的单位可以是分钟、小时、日、月、周的任意组合。
这里我们看一看 crontab 的格式 # Example of job definition: # .---------------- minute (0 - 59) # | .------------- hour (0 - 23) # | | .---------- day of month (1 - 31) # | | | .------- month (1 - 12) OR jan,feb,mar,apr ... # | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat # | | | | | # * * * * * user-name command to be executed 使用方法 通过下面一个命令来添加一个计划任务</description>
    </item>
    
    <item>
      <title>Linux命令-文件、磁盘管理</title>
      <link>http://example.org/posts/linux%E5%91%BD%E4%BB%A4-%E6%96%87%E4%BB%B6%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/</link>
      <pubDate>Wed, 13 May 2020 07:20:56 +0000</pubDate>
      
      <guid>http://example.org/posts/linux%E5%91%BD%E4%BB%A4-%E6%96%87%E4%BB%B6%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/</guid>
      <description>Linux命令-文件、磁盘管理 文件管理 查看文件信息：ls Linux文件或者目录名称最长可以有265个字符，“.”代表当前目录，“..”代表上一级目录，以“.”开头的文件为隐藏文件，需要用 -a 参数才能显示。
ls常用参数：
   参数 含义     -a 显示所有档案及目录（ls内定将档案名或目录名称为“.”的视为影藏，不会列出）；   -A 显示除隐藏文件“.”和“..”以外的所有文件列表；   -C 多列显示输出结果。这是默认选项；   -l 与“-C”选项功能相反，所有输出信息用单列格式输出，不输出为多列；   -F 在每个输出项后追加文件的类型标识符，具体含义：“*”表示具有可执行权限的普通文件，“/”表示目录，“@”表示符号链接，“   -b 将文件中的不可输出的字符以反斜线“”加字符编码的方式输出；   -c 与“-lt”选项连用时，按照文件状态时间排序输出目录内容，排序的依据是文件的索引节点中的ctime字段。与“-l”选项连用时，则排序的一句是文件的状态改变时间；   -d 仅显示目录名，而不显示目录下的内容列表。显示符号链接文件本身，而不显示其所指向的目录列表；   -f 此参数的效果和同时指定“aU”参数相同，并关闭“lst”参数的效果；   -i 显示文件索引节点号（inode）。一个索引节点代表一个文件；   &amp;ndash;file-type 与“-F”选项的功能相同，但是不显示“*”；   -k 以KB（千字节）为单位显示文件大小；   -l 以长格式显示目录下的内容列表。输出的信息从左到右依次包括文件名，文件类型、权限模式、硬连接数、所有者、组、文件大小和文件的最后修改时间等；   -m 用“,”号区隔每个文件和目录的名称；   -n 以用户识别码和群组识别码替代其名称；   -r 以文件名反序排列并输出目录内容列表；   -s 显示文件和目录的大小，以区块为单位；   -t 用文件和目录的更改时间排序；   -L 如果遇到性质为符号链接的文件或目录，直接列出该链接所指向的原始文件或目录；   -R 递归处理，将指定目录下的所有文件及子目录一并处理；   &amp;ndash;full-time 列出完整的日期与时间；   &amp;ndash;color[=WHEN] 使用不同的颜色高亮显示不同类型的。    图中列出的信息含义如下图所示：    通配符 含义     * 文件代表文件名中所有字符   ls te* 查找以te开头的文件   ls *html 查找结尾为html的文件   ?</description>
    </item>
    
    <item>
      <title>数据流重定向</title>
      <link>http://example.org/posts/%E6%95%B0%E6%8D%AE%E6%B5%81%E9%87%8D%E5%AE%9A%E5%90%91/</link>
      <pubDate>Tue, 12 May 2020 08:43:29 +0000</pubDate>
      
      <guid>http://example.org/posts/%E6%95%B0%E6%8D%AE%E6%B5%81%E9%87%8D%E5%AE%9A%E5%90%91/</guid>
      <description>数据流重定向 简单重定向 在更多了解 Linux 的重定向之前，我们需要先知道一些基本的东西，前面我们已经提到过 Linux 默认提供了三个特殊设备，用于终端的显示和输出，分别为stdin（标准输入,对应于你在终端的输入），stdout（标准输出，对应于终端的输出），stderr（标准错误输出，对应于终端的输出）。
   文件描述符 设备文件 说明     0 /dev/stdin 标准输入   1 /dev/stdout 标准输出   2 /dev/stderr 标准错误     文件描述符：文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于 UNIX、Linux 这样的操作系统。
 我们可以这样使用这些文件描述符：
默认使用终端的标准输入作为命令的输入和标准输出作为命令的输出
$ cat （按Ctrl+C退出） 将 cat 的连续输出（heredoc 方式）重定向到一个文件
$ mkdir Documents $ cat &amp;gt; Documents/test.c &amp;lt;&amp;lt;EOF #include &amp;lt;stdio.h&amp;gt; int main() { printf(&amp;quot;hello world\n&amp;quot;); return 0; } EOF 将一个文件作为命令的输入，标准输出作为命令的输出
$ cat Documents/test.c 将 echo 命令通过管道传过来的数据作为 cat 命令的输入，将标准输出作为命令的输出</description>
    </item>
    
    <item>
      <title>在 Linux 中找到最大的 10 个文件</title>
      <link>http://example.org/posts/%E5%9C%A8-linux-%E4%B8%AD%E6%89%BE%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84-10-%E4%B8%AA%E6%96%87%E4%BB%B6/</link>
      <pubDate>Tue, 12 May 2020 07:46:31 +0000</pubDate>
      
      <guid>http://example.org/posts/%E5%9C%A8-linux-%E4%B8%AD%E6%89%BE%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84-10-%E4%B8%AA%E6%96%87%E4%BB%B6/</guid>
      <description>在 Linux 中找到最大的 10 个文件 当系统的磁盘空间不足时，您可能会使用 df、du 或 ncdu 命令进行检查，但这些命令只会显示当前目录的文件，并不会显示整个系统范围的文件。
您得花费大量的时间才能用上述命令获取系统中最大的文件，因为要进入到每个目录重复运行上述命令。
这种方法比较麻烦，也并不恰当。
如果是这样，那么该如何在 Linux 中找到最大的 10 个文件呢？
我在谷歌上搜索了很久，却没发现类似的文章，我反而看到了很多关于列出当前目录中最大的 10 个文件的文章。所以，我希望这篇文章对那些有类似需求的人有所帮助。
本教程中，我们将教您如何使用以下四种方法在 Linux 系统中查找最大的前 10 个文件。
方法 1 在 Linux 中没有特定的命令可以直接执行此操作，因此我们需要将多个命令结合使用。
  # find / -type f -print0 | xargs -0 du -h | sort -rh | head -n 10
  1.4G /swapfile
  1.1G /home/magi/ubuntu-17.04-desktop-amd64.iso
  564M /home/magi/.gdfuse/magi/cache/0B5nso_FPaZFqTFU0XzkzUlJUZzA
  378M /home/magi/.gdfuse/magi/cache/0B5nso_FPaZFqeldzUmhPeC03Zm8
  377M /home/magi/.gdfuse/magi/cache/0B5nso_FPaZFqRGd4V0VrOXM4YVU</description>
    </item>
    
    <item>
      <title>压缩与解压</title>
      <link>http://example.org/posts/%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B/</link>
      <pubDate>Tue, 12 May 2020 06:39:26 +0000</pubDate>
      
      <guid>http://example.org/posts/%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B/</guid>
      <description>压缩与解压 总结 zip  打包 ：zip something.zip something （目录请加 -r 参数） 解包：unzip something.zip 指定路径：-d 参数  tar  打包：tar -cf something.tar something 解包：tar -xf something.tar 指定路径：-C 参数  tar打包工具  创建一个 tar 包(创建归档文件)：  $ cd [/home/user] $ tar -P -cf [filename].tar [/home/user/sourcesolder] 上面命令中，-P 保留绝对路径符，-c 表示创建一个 tar 包文件，-f 用于指定创建的文件名，注意文件名必须紧跟在 -f 参数之后，比如不能写成 tar -fc [filename].tar，可以写成 tar -f [filename].tar -c ~。你还可以加上 -v 参数以可视的的方式输出打包的文件。
 解包一个文件（-x 参数）到指定路径的已存在目录（-C 参数）：  $ mkdir tardir $ tar -xf [filename].</description>
    </item>
    
    <item>
      <title>Ubuntu软件操作的相关命令</title>
      <link>http://example.org/posts/ubuntu%E8%BD%AF%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9A%84%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Tue, 12 May 2020 06:37:53 +0000</pubDate>
      
      <guid>http://example.org/posts/ubuntu%E8%BD%AF%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9A%84%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/</guid>
      <description>Ubuntu软件操作的相关命令    命令 功能     sudo apt-get update 更新源   sudo apt-get install package 安装包   sudo apt-get remove package 删除包   sudo apt-cache search package 搜索软件包   sudo apt-cache show package 获取包的相关信息，如说明、大小、版本等   sudo apt-get install package &amp;ndash;reinstall 重新安装包   sudo apt-get -f install 修复安装   sudo apt-get remove package &amp;ndash;purge 删除包，包括配置文件等   sudo apt-get build-dep package 安装相关的编译环境   sudo apt-get upgrade 更新已安装的包   sudo apt-get dist-upgrade 升级系统   sudo apt-cache depends package 了解使用该包依赖那些包   sudo apt-cache rdepends package 查看该包被哪些包依赖   sudo apt-get source package 下载该包的源代码   sudo apt-get clean &amp;amp;&amp;amp; sudo apt-get autoclean 清理无用的包   sudo apt-get check 检查是否有损坏的依赖    更新Ubuntu软件下载地址   寻找国内镜像源 所谓的镜像源：可以理解为提供下载软件的地方，比如Android手机上可以下载软件的91手机助手；iOS手机上可以下载软件的AppStore   备份Ubuntu默认的源地址 sudo cp /etc/apt/sources.</description>
    </item>
    
    <item>
      <title>Linux命令-系统管理</title>
      <link>http://example.org/posts/linux%E5%91%BD%E4%BB%A4-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/</link>
      <pubDate>Tue, 12 May 2020 06:26:58 +0000</pubDate>
      
      <guid>http://example.org/posts/linux%E5%91%BD%E4%BB%A4-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/</guid>
      <description>Linux命令-系统管理 查看系统信息    命令 功能     cat /etc/issue 查看部分Linux发行版版本   lsb_release -a 查看部分Linux发行版版本   cat /etc/redhat-release 查看RedHat系Linux版本   uname -a 查看系统内核信息   cat /proc/cpuinfo 查看CPU信息   free -m 查看内存信息   df -h 硬盘分区信息   fdisk -l 硬盘分区信息   du -sh 查看目录占用大小   ifconfig 查看网络信息   hostname 查看主机名   env 查看环境变量    查看当前日历：cal cal命令用于查看当前日历，-y显示整年日历</description>
    </item>
    
    <item>
      <title>Linux 系统目录结构</title>
      <link>http://example.org/posts/linux-%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</link>
      <pubDate>Mon, 11 May 2020 13:07:21 +0000</pubDate>
      
      <guid>http://example.org/posts/linux-%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</guid>
      <description>Linux 系统目录结构 登录系统后，在当前命令窗口下输入命令：
ls /
你会看到如下图所示:
树状目录结构：
以下是对这些目录的解释：
  /bin： bin是Binary的缩写, 这个目录存放着最经常使用的命令。
  /boot： 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。
  /dev ： dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。
  /etc： 这个目录用来存放所有的系统管理所需要的配置文件和子目录。
  /home： 用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。
  /lib： 这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。
  /lost+found： 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。
  /media： linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。
  /mnt： 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。
  /opt： 这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。
  /proc： 这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。 这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：
echo 1 &amp;gt; /proc/sys/net/ipv4/icmp_echo_ignore_all
  /root： 该目录为系统管理员，也称作超级权限者的用户主目录。
  /sbin： s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。
  /selinux： 这个目录是Redhat/CentOS所特有的目录，Selinux是一个安全机制，类似于windows的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</description>
    </item>
    
    <item>
      <title>centos常见错误</title>
      <link>http://example.org/posts/centos%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/</link>
      <pubDate>Mon, 11 May 2020 12:58:03 +0000</pubDate>
      
      <guid>http://example.org/posts/centos%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/</guid>
      <description>centos常见错误 Failed to set locale, defaulting to C 错误描述： 当在centos中使用yum命令时，输出错误： Failed to set locale, defaulting to C 用locale检测，出现如下提示：
locale：Cannot set LC\_CTYPE to default locale： No such file or directory ocale：Cannot set LC\_MESSAGES to default locale： No such file or directory locale：Cannot set LC\_ALL to default locale： No such file or directory 错误分析： 查询可知locale是用来设置语言环境的，故此需要查看并正确设置locale 解决方案： echo &amp;quot;export LC\_ALL\=en\_US.UTF\-8&amp;quot; \&amp;gt;\&amp;gt; /etc/profile 执行命令后重新登录即可！</description>
    </item>
    
    <item>
      <title>CentOS系统设置</title>
      <link>http://example.org/posts/centos%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE/</link>
      <pubDate>Mon, 11 May 2020 12:58:03 +0000</pubDate>
      
      <guid>http://example.org/posts/centos%E7%B3%BB%E7%BB%9F%E8%AE%BE%E7%BD%AE/</guid>
      <description>CentOS系统设置 修改时区 设置时区同样, 在 CentOS 7 中, 引入了一个叫 timedatectl 的设置设置程序.
 timedatectl # 查看系统时间方面的各种状态 timedatectl list-timezones # 列出所有时区 timedatectl set-local-rtc 1 # 将硬件时钟调整为与本地时钟一致, 0 为设置为 UTC 时间 timedatectl set-timezone Asia/Shanghai # 设置系统时区为上海 其实不考虑各个发行版的差异化, 从更底层出发的话, 修改时间时区比想象中要简单: cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime  </description>
    </item>
    
    <item>
      <title>Fun on LINUX</title>
      <link>http://example.org/posts/fun-on-linux/</link>
      <pubDate>Mon, 11 May 2020 12:58:03 +0000</pubDate>
      
      <guid>http://example.org/posts/fun-on-linux/</guid>
      <description>Fun on LINUX 图形字符命令 $ sudo apt-get update $ sudo apt-get install sysvbanner 或者你觉得这字体不好看，那么你还可以使用默认已经安装的一个命令printerbanner： $ printerbanner -w 50 A -w参数指定打印宽度，因为我们的环境在屏幕中显示比较小，必须要加上宽度限制
toilet 与 figlet 也具有同一效果</description>
    </item>
    
    <item>
      <title>Linux命令-用户、权限管理</title>
      <link>http://example.org/posts/linux%E5%91%BD%E4%BB%A4-%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</link>
      <pubDate>Mon, 11 May 2020 12:58:03 +0000</pubDate>
      
      <guid>http://example.org/posts/linux%E5%91%BD%E4%BB%A4-%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</guid>
      <description>Linux命令-用户、权限管理 查看当前用户：whoami whoami该命令用户查看当前系统当前账号的用户名。可通过cat /etc/passwd查看系统用户信息。
由于系统管理员通常需要使用多种身份登录系统，例如通常使用普通用户登录系统，然后再以su命令切换到root身份对传统进行管理。这时候就可以使用whoami来查看当前用户的身份。
查看登录用户：who who命令用于查看当前所有登录系统的用户信息。
常用选项：
   选项 含义     -m或am I 只显示运行who命令的用户名、登录终端和登录时间   -q或&amp;ndash;count 只显示用户的登录账号和登录用户的数量   -u 在登录时间后显示该用户最后一次操作到当前的时间间隔   -u或&amp;ndash;heading 显示列标题    退出登录账户： exit 如果是图形界面，退出当前终端；
如果是使用ssh远程登录，退出登陆账户；
如果是切换后的登陆用户，退出则返回上一个登陆账号。
添加用户账号：useradd 在Unix/Linux中添加用户账号可以使用adduser或useradd命令，因为adduser命令是指向useradd命令的一个链接，因此，这两个命令的使用格式完全一样。
useradd命令的使用格式如下： useradd [参数] 新建用户账号
   参数 含义     -d 指定用户登录系统时的主目录，如果不使用该参数，系统自动在/home目录下建立与用户名同名目录为主目录   -m 自动建立目录   -g 指定组名称       相关说明：</description>
    </item>
    
    <item>
      <title>RPM</title>
      <link>http://example.org/posts/rpm/</link>
      <pubDate>Mon, 11 May 2020 12:58:03 +0000</pubDate>
      
      <guid>http://example.org/posts/rpm/</guid>
      <description>RPM </description>
    </item>
    
    <item>
      <title>sed 流编辑器</title>
      <link>http://example.org/posts/sed-%E6%B5%81%E7%BC%96%E8%BE%91%E5%99%A8/</link>
      <pubDate>Mon, 11 May 2020 12:58:03 +0000</pubDate>
      
      <guid>http://example.org/posts/sed-%E6%B5%81%E7%BC%96%E8%BE%91%E5%99%A8/</guid>
      <description>sed 流编辑器 常用参数 sed 命令基本格式：
sed [参数]... [执行命令] [输入文件]... # 形如： $ sed -i &#39;s/sad/happy/&#39; test # 表示将test文件中的&amp;quot;sad&amp;quot;替换为&amp;quot;happy&amp;quot;    参数 说明     -n 安静模式，只打印受影响的行，默认打印输入数据的全部内容   -e 用于在脚本中添加多个执行命令一次执行，在命令行中执行多个命令通常不需要加该参数   -f filename 指定执行 filename 文件中的命令   -r 使用扩展正则表达式，默认为标准正则表达式   -i 将直接修改输入文件内容，而不是打印到标准输出设备    sed 执行命令（这里”执行“解释为名词） sed 执行命令格式：
[n1][,n2]command [n1][~step]command # 其中一些命令可以在后面加上作用范围，形如： $ sed -i &#39;s/sad/happy/g&#39; test # g表示全局范围 $ sed -i &#39;s/sad/happy/4&#39; test # 4表示指定行中的第四个匹配字符串 其中 n1,n2 表示输入内容的行号，它们之间为,逗号则表示从 n1 到 n2 行，如果为～波浪号则表示从 n1 开始以 step 为步进的所有行；command 为执行动作，下面为一些常用动作指令：</description>
    </item>
    
    <item>
      <title>Systemd 入门教程：命令篇</title>
      <link>http://example.org/posts/systemd-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%E5%91%BD%E4%BB%A4%E7%AF%87/</link>
      <pubDate>Mon, 11 May 2020 12:58:03 +0000</pubDate>
      
      <guid>http://example.org/posts/systemd-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%E5%91%BD%E4%BB%A4%E7%AF%87/</guid>
      <description>Systemd 入门教程：命令篇 作者： 阮一峰
日期： 2016年3月 7日
Systemd 是 Linux 系统工具，用来启动守护进程，已成为大多数发行版的标准配置。
本文介绍它的基本用法，分为上下两篇。今天介绍它的主要命令，下一篇介绍如何用于实战。
一、由来 历史上，Linux 的启动一直采用init进程。
下面的命令用来启动服务。
 $ sudo /etc/init.d/apache2 start # 或者 $ service apache2 start  这种方法有两个缺点。
一是启动时间长。init进程是串行启动，只有前一个进程启动完，才会启动下一个进程。
二是启动脚本复杂。init进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。
二、Systemd 概述 Systemd 就是为了解决这些问题而诞生的。它的设计目标是，为系统的启动和管理提供一套完整的解决方案。
根据 Linux 惯例，字母d是守护进程（daemon）的缩写。 Systemd 这个名字的含义，就是它要守护整个系统。
（上图为 Systemd 作者 Lennart Poettering）
使用了 Systemd，就不需要再用init了。Systemd 取代了initd，成为系统的第一个进程（PID 等于 1），其他进程都是它的子进程。
 $ systemctl --version  上面的命令查看 Systemd 的版本。
Systemd 的优点是功能强大，使用方便，缺点是体系庞大，非常复杂。事实上，现在还有很多人反对使用 Systemd，理由就是它过于复杂，与操作系统的其他部分强耦合，违反&amp;quot;keep simple, keep stupid&amp;quot;的Unix 哲学。
（上图为 Systemd 架构图）
三、系统管理 Systemd 并不是一个命令，而是一组命令，涉及到系统管理的方方面面。</description>
    </item>
    
    <item>
      <title>Systemd 入门教程：实战篇</title>
      <link>http://example.org/posts/systemd-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AF%87/</link>
      <pubDate>Mon, 11 May 2020 12:58:03 +0000</pubDate>
      
      <guid>http://example.org/posts/systemd-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%E5%AE%9E%E6%88%98%E7%AF%87/</guid>
      <description>Systemd 入门教程：实战篇 作者： 阮一峰
日期： 2016年3月 8日
上一篇文章，我介绍了 Systemd 的主要命令，今天介绍如何使用它完成一些基本的任务。
一、开机启动 对于那些支持 Systemd 的软件，安装的时候，会自动在/usr/lib/systemd/system目录添加一个配置文件。
如果你想让该软件开机启动，就执行下面的命令（以httpd.service为例）。
 $ sudo systemctl enable httpd  上面的命令相当于在/etc/systemd/system目录添加一个符号链接，指向/usr/lib/systemd/system里面的httpd.service文件。
这是因为开机时，Systemd只执行/etc/systemd/system目录里面的配置文件。这也意味着，如果把修改后的配置文件放在该目录，就可以达到覆盖原始配置的效果。
二、启动服务 设置开机启动以后，软件并不会立即启动，必须等到下一次开机。如果想现在就运行该软件，那么要执行systemctl start命令。
 $ sudo systemctl start httpd  执行上面的命令以后，有可能启动失败，因此要用systemctl status命令查看一下该服务的状态。
 $ sudo systemctl status httpd httpd.service - The Apache HTTP Server Loaded: loaded (/usr/lib/systemd/system/httpd.service; enabled) Active: active (running) since 金 2014-12-05 12:18:22 JST; 7min ago Main PID: 4349 (httpd) Status: &amp;#34;Total requests: 1; Current requests/sec: 0; Current traffic: 0 B/sec&amp;#34; CGroup: /system.</description>
    </item>
    
    <item>
      <title>文件搜索</title>
      <link>http://example.org/posts/%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2/</link>
      <pubDate>Mon, 11 May 2020 12:58:03 +0000</pubDate>
      
      <guid>http://example.org/posts/%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2/</guid>
      <description>文件搜索 与搜索相关的命令常用的有 whereis，which，find 和 locate。
 whereis简单快速  $ whereis who $ whereis find 你会看到 whereis find 找到了三个路径，两个可执行文件路径和一个 man 在线帮助文件所在路径，这个搜索很快，因为它并没有从硬盘中依次查找，而是直接从数据库中查询。
whereis 只能搜索二进制文件(-b)，man 帮助文件(-m)和源代码文件(-s)。如果想要获得更全面的搜索结果可以使用 locate 命令。
 locate快而全  使用 locate 命令查找文件也不会遍历硬盘，它通过查询 /var/lib/mlocate/mlocate.db 数据库来检索信息。不过这个数据库也不是实时更新的，系统会使用定时任务每天自动执行 updatedb 命令来更新数据库。所以有时候你刚添加的文件，它可能会找不到，需要手动执行一次 updatedb 命令（在我们的环境中必须先执行一次该命令）。注意这个命令也不是内置的命令，例如在我们的环境中就需要手动安装，然后执行更新。
$ sudo apt-get update $ sudo apt-get install locate $ sudo updatedb 它可以用来查找指定目录下的不同文件类型，如查找 /etc 下所有以 sh 开头的文件：
$ locate /etc/sh  注意，它不只是在 /etc 目录下查找，还会自动递归子目录进行查找。
 查找 /usr/share/ 下所有 jpg 文件：
$ locate /usr/share/\*.jpg  注意要添加 * 号前面的反斜杠转义，否则会无法找到。</description>
    </item>
    
    <item>
      <title>文件系统操作与磁盘管理</title>
      <link>http://example.org/posts/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C%E4%B8%8E%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/</link>
      <pubDate>Mon, 11 May 2020 12:58:03 +0000</pubDate>
      
      <guid>http://example.org/posts/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C%E4%B8%8E%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/</guid>
      <description>文件系统操作与磁盘管理   df查看磁盘容量  /dev/sda2 是对应着主机硬盘的分区，后面的数字表示分区号，数字前面的字母 a 表示第几块硬盘（也可能是可移动磁盘），你如果主机上有多块硬盘则可能还会出现 /dev/sdb，/dev/sdc 这些磁盘设备都会在 /dev 目录下以文件的存在形式。
  df -h 以易读的形式显示容量大小    du 查看目录大小
  -d 参数指定查看目录的深度
# 只查看1级目录的信息 $ du -h -d 0 ~ # 查看2级 $ du -h -d 1 ~   常用参数
du -h #同--human-readable 以K，M，G为单位，提高信息的可读性。 du -a #同--all 显示目录中所有文件的大小。 du -s #同--summarize 仅显示总计，只列出最后加总的值。     创建虚拟磁盘 dd 命令简介（部分说明来自dd (Unix) wiki） dd命令用于转换和复制文件，不过它的复制不同于cp。之前提到过关于 Linux 的很重要的一点，一切即文件，在 Linux 上，硬件的设备驱动（如硬盘）和特殊设备文件（如/dev/zero和/dev/random）都像普通文件一样，只是在各自的驱动程序中实现了对应的功能，dd 也可以读取文件或写入这些文件。这样，dd也可以用在备份硬件的引导扇区、获取一定数量的随机数据或者空数据等任务中。dd程序也可以在复制时处理数据，例如转换字节序、或在 ASCII 与 EBCDIC 编码间互换。</description>
    </item>
    
    <item>
      <title>日志系统</title>
      <link>http://example.org/posts/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Mon, 11 May 2020 12:58:03 +0000</pubDate>
      
      <guid>http://example.org/posts/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</guid>
      <description>日志系统 日志是一个系统管理员，一个运维人员，甚至是开发人员不可或缺的东西，系统用久了偶尔也会出现一些错误，我们需要日志来给系统排错，在一些网络应用服务不能正常工作的时候，我们需要用日志来做问题定位，日志还是过往时间的记录本，我们可以通过它知道我们是否被不明用户登录过等等。
在 Linux 中大部分的发行版都内置使用 syslog 系统日志，那么通过前期的课程我们了解到常见的日志一般存放在 /var/log 中，我们来看看其中有哪些日志
根据图中所显示的日志，我们可以根据服务对象粗略的将日志分为两类
 系统日志 应用日志  系统日志主要是存放系统内置程序或系统内核之类的日志信息如 alternatives.log 、btmp 等等，应用日志主要是我们装的第三方应用所产生的日志如 tomcat7 、apache2 等等。
接下来我们来看看常见的系统日志有哪些，他们都记录了怎样的信息
   日志名称 记录信息     alternatives.log 系统的一些更新替代信息记录   apport.log 应用程序崩溃信息记录   apt/history.log 使用 apt-get 安装卸载软件的信息记录   apt/term.log 使用 apt-get 时的具体操作，如 package 的下载、打开等   auth.log 登录认证的信息记录   boot.log 系统启动时的程序服务的日志信息   btmp 错误的信息记录   Consolekit/history 控制台的信息记录   dist-upgrade dist-upgrade 这种更新方式的信息记录   dmesg 启动时，显示屏幕上内核缓冲信息,与硬件有关的信息   dpkg.</description>
    </item>
    
    <item>
      <title>正则表达式</title>
      <link>http://example.org/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Mon, 11 May 2020 12:58:03 +0000</pubDate>
      
      <guid>http://example.org/posts/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>正则表达式 一个正则表达式通常被称为一个模式（pattern），为用来描述或者匹配一系列符合某个句法规则的字符串。
选择 |竖直分隔符表示选择，例如&amp;quot;boy|girl&amp;quot;可以匹配&amp;quot;boy&amp;quot;或者&amp;quot;girl&amp;rdquo;
数量限定 数量限定除了我们举例用的*,还有+加号,?问号,如果在一个模式中不加数量限定符则表示出现一次且仅出现一次：
 +表示前面的字符必须出现至少一次(1 次或多次)，例如，&amp;ldquo;goo+gle&amp;rdquo;,可以匹配&amp;quot;gooogle&amp;rdquo;,&amp;ldquo;goooogle&amp;quot;等； ?表示前面的字符最多出现一次(0 次或 1 次)，例如，&amp;ldquo;colou?r&amp;rdquo;,可以匹配&amp;quot;color&amp;quot;或者&amp;quot;colour&amp;rdquo;; *星号代表前面的字符可以不出现，也可以出现一次或者多次（0 次、或 1 次、或多次），例如，“0*42”可以匹配 42、042、0042、00042 等。  范围和优先级 ()圆括号可以用来定义模式字符串的范围和优先级，这可以简单的理解为是否将括号内的模式串作为一个整体。例如，&amp;ldquo;gr(a|e)y&amp;quot;等价于&amp;quot;gray|grey&amp;rdquo;，（这里体现了优先级，竖直分隔符用于选择 a 或者 e 而不是 gra 和 ey），&amp;quot;(grand)?father&amp;quot;匹配 father 和 grandfather（这里体现了范围，?将圆括号内容作为一个整体匹配）。
语法（部分） 正则表达式有多种不同的风格，下面列举一些常用的作为 PCRE 子集的适用于perl和python编程语言及grep或egrep的正则表达式匹配规则：(由于 markdown 表格解析的问题，下面的竖直分隔符用全角字符代替，实际使用时请换回半角字符)
 PCRE（Perl Compatible Regular Expressions 中文含义：perl 语言兼容正则表达式）是一个用 C 语言编写的正则表达式函数库，由菲利普.海泽(Philip Hazel)编写。PCRE 是一个轻量级的函数库，比 Boost 之类的正则表达式库小得多。PCRE 十分易用，同时功能也很强大，性能超过了 POSIX 正则表达式库和一些经典的正则表达式库。
    字符 描述     \ **将下一个字符标记为一个特殊字符、或一个原义字符。**例如，“n”匹配字符“n”。“\n”匹配一个换行符。序列“\\”匹配“\”而“\(”则匹配“(”。   ^ 匹配输入字符串的开始位置。   $ 匹配输入字符串的结束位置。   {n} n 是一个非负整数。匹配确定的 n 次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个 o。   {n,} n 是一个非负整数。至少匹配 n 次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有 o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。   {n,m} m 和 n 均为非负整数，其中 n&amp;lt;=m。**最少匹配 n 次且最多匹配 m 次。**例如，“o{1,3}”将匹配“fooooood”中的前三个 o。“o{0,1}”等价于“o?</description>
    </item>
    
    <item>
      <title>环境变量</title>
      <link>http://example.org/posts/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</link>
      <pubDate>Mon, 11 May 2020 12:58:03 +0000</pubDate>
      
      <guid>http://example.org/posts/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</guid>
      <description>环境变量 变量 使用 declare 命令创建一个变量名为 tmp 的变量： $ declare tmp
 其实也可以不用 declare 预声明一个变量，直接即用即创建，这里只是告诉你 declare 的作用，这在创建其它指定类型的变量（如数组）时会用到。
 使用 = 号赋值运算符，将变量 tmp 赋值为 shiyanlou。注意，与其他语言不同的是， Shell 中的赋值操作，= 两边不可以输入空格，否则会报错。
# 正确的赋值 $ tmp=shiyanlou # 错误的赋值 $ tmp = shiyanlou 读取变量的值，使用 echo 命令和 $ 符号（$ 符号用于表示引用一个变量的值，初学者经常忘记输入）：
环境变量 环境变量的作用域比自定义变量的要大，如 Shell 的环境变量作用于自身和它的子进程。在所有的 UNIX 和类 UNIX 系统中，每个进程都有其各自的环境变量设置，且默认情况下，当一个进程被创建时，除了创建过程中明确指定的话，它将继承其父进程的绝大部分环境设置。Shell 程序也作为一个进程运行在操作系统之上，而我们在 Shell 中运行的大部分命令都将以 Shell 的子进程的方式运行。
通常我们会涉及到的变量类型有三种：
 当前 Shell 进程私有用户自定义变量，如上面我们创建的 tmp 变量，只在当前 Shell 中有效。 Shell 本身内建的变量。 从自定义变量导出的环境变量。  也有三个与上述三种环境变量相关的命令：set，env，export。这三个命令很相似，都是用于打印环境变量信息，区别在于涉及的变量范围不同。详见下表：
   命 令 说 明     set 显示当前 Shell 所有变量，包括其内建环境变量（与 Shell 外观等相关），用户自定义变量及导出的环境变量。   env 显示与当前用户相关的环境变量，还可以让命令在指定环境中运行。   export 显示从 Shell 中导出成环境变量的变量，也能通过它将自定义变量导出为环境变量。    你可以更直观的使用 vimdiff 工具比较一下它们之间的差别：</description>
    </item>
    
    <item>
      <title>理解 Linux 的硬链接与软链接</title>
      <link>http://example.org/posts/%E7%90%86%E8%A7%A3-linux-%E7%9A%84%E7%A1%AC%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%BD%AF%E9%93%BE%E6%8E%A5/</link>
      <pubDate>Mon, 11 May 2020 12:58:03 +0000</pubDate>
      
      <guid>http://example.org/posts/%E7%90%86%E8%A7%A3-linux-%E7%9A%84%E7%A1%AC%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%BD%AF%E9%93%BE%E6%8E%A5/</guid>
      <description>理解 Linux 的硬链接与软链接 Linux 的文件与目录 现代操作系统为解决信息能独立于进程之外被长期存储引入了文件，文件作为进程创建信息的逻辑单元可被多个进程并发使用。在 UNIX 系统中，操作系统为磁盘上的文本与图像、鼠标与键盘等输入设备及网络交互等 I/O 操作设计了一组通用 API，使他们被处理时均可统一使用字节流方式。换言之，UNIX 系统中除进程之外的一切皆是文件，而 Linux 保持了这一特性。为了便于文件的管理，Linux 还引入了目录（有时亦被称为文件夹）这一概念。目录使文件可被分类管理，且目录的引入使 Linux 的文件系统形成一个层级结构的目录树。 清单 1.所示的是普通 Linux 系统的顶层目录结构，其中 /dev 是存放了设备相关文件的目录。
清单 1. Linux 系统的顶层目录结构 / 根目录 ├── bin 存放用户二进制文件 ├── boot 存放内核引导配置文件 ├── dev 存放设备文件 ├── etc 存放系统配置文件 ├── home 用户主目录 ├── lib 动态共享库 ├── lost+found 文件系统恢复时的恢复文件 ├── media 可卸载存储介质挂载点 ├── mnt 文件系统临时挂载点 ├── opt 附加的应用程序包 ├── proc 系统内存的映射目录，提供内核与进程信息 ├── root root 用户主目录 ├── sbin 存放系统二进制文件 ├── srv 存放服务相关数据 ├── sys sys 虚拟文件系统挂载点 ├── tmp 存放临时文件 ├── usr 存放用户应用程序 └── var 存放邮件、系统日志等变化文件 Linux 与其他类 UNIX 系统一样并不区分文件与目录：目录是记录了其他文件名的文件。使用命令 mkdir 创建目录时，若期望创建的目录的名称与现有的文件名（或目录名）重复，则会创建失败。</description>
    </item>
    
    <item>
      <title>练习</title>
      <link>http://example.org/posts/%E7%BB%83%E4%B9%A0/</link>
      <pubDate>Mon, 11 May 2020 12:58:03 +0000</pubDate>
      
      <guid>http://example.org/posts/%E7%BB%83%E4%B9%A0/</guid>
      <description>练习 挑战：历史命令 在 Linux 中，对于文本的处理和分析是极为重要的，现在有一个文件叫做 data1，可以使用下面的命令下载：
$ cd /home/shiyanlou $ wget http://labfile.oss.aliyuncs.com/courses/1/data1 data1 文件里记录是一些命令的操作记录，现在需要你从里面找出出现频率次数前 3 的命令并保存在 /home/shiyanlou/result。
目标  处理文本文件 /home/shiyanlou/data1 将结果写入 /home/shiyanlou/result 结果包含三行内容，每行内容都是出现的次数和命令名称，如“100 ls”  提示  cut 截取 (参数可以使用 -c 8-，使用 man cut 可以查看含义) uniq -dc 去重 sort 的参数选择 -k1 -n -r 操作过程使用管道，例如：  $ cd /home/shiyanlou $ cat data1 |....|....|.... &amp;gt; /home/shiyanlou/result 来源 2016 年百度校招面试题
参考答案 注意：请务必自己独立思考解决问题之后再对照参考答案，一开始直接看参考答案收获不大。
cat data1 |cut -c 8-|sort|uniq -dc|sort -rn -k1 |head -3 &amp;gt; /home/shiyanlou/result 挑战：数据提取 介绍 小明在做数据分析的时候需要提取文件中关于数字的部分，同时还要提取用户的邮箱部分，但是有的行不是数组也不是邮箱，现在需要你在 data2 这个文件中帮助他用正则表达式匹配出数字部分和邮箱部分。</description>
    </item>
    
    <item>
      <title>终端操作快捷键</title>
      <link>http://example.org/posts/%E7%BB%88%E7%AB%AF%E6%93%8D%E4%BD%9C%E5%BF%AB%E6%8D%B7%E9%94%AE/</link>
      <pubDate>Mon, 11 May 2020 12:58:03 +0000</pubDate>
      
      <guid>http://example.org/posts/%E7%BB%88%E7%AB%AF%E6%93%8D%E4%BD%9C%E5%BF%AB%E6%8D%B7%E9%94%AE/</guid>
      <description>终端操作快捷键    按键 功能     TAB 自动补全   Ctrl+d 键盘输入结束或退出终端   Ctrl+s 暂停当前程序，暂停后按下任意键恢复运行   Ctrl+z 将当前程序放到后台运行，恢复到前台为命令fg   Ctrl+a 将光标移至输入行头，相当于Home键   Ctrl+e 将光标移至输入行末，相当于End键   Ctrl+k 删除从光标所在位置到行末   Alt+Backspace 向前删除一个单词   Shift+PgUp 将终端显示向上滚动   Shift+PgDn 将终端显示向下滚动    </description>
    </item>
    
    <item>
      <title>进程管理</title>
      <link>http://example.org/posts/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</link>
      <pubDate>Mon, 11 May 2020 12:58:03 +0000</pubDate>
      
      <guid>http://example.org/posts/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</guid>
      <description>进程管理 top top 工具是我们常用的一个查看工具，能实时的查看我们系统的一些关键信息的变化:
top top 是一个在前台执行的程序，所以执行后便进入到这样的一个交互界面，正是因为交互界面我们才可以实时的获取到系统与进程的信息。在交互界面中我们可以通过一些指令来操作和筛选。在此之前我们先来了解显示了哪些信息。
我们看到 top 显示的第一排，
   内容 解释     top 表示当前程序的名称   11:05:18 表示当前的系统的时间   up 8 days,17:12 表示该机器已经启动了多长时间   1 user 表示当前系统中只有一个用户   load average: 0.29,0.20,0.25 分别对应 1、5、15 分钟内 cpu 的平均负载    load average 在 wikipedia 中的解释是 the system load is a measure of the amount of work that a computer system is doing 也就是对当前 CPU 工作量的度量，具体来说也就是指运行队列的平均长度，也就是等待 CPU 的平均进程数相关的一个计算值。</description>
    </item>
    
    <item>
      <title>顺序执行控制与统计查找</title>
      <link>http://example.org/posts/%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%9F%E8%AE%A1%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Mon, 11 May 2020 12:58:03 +0000</pubDate>
      
      <guid>http://example.org/posts/%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%BB%9F%E8%AE%A1%E6%9F%A5%E6%89%BE/</guid>
      <description>顺序执行控制与统计查找 顺序执行多条命令 $ sudo apt-get update;sudo apt-get install some-tool;some-tool # 按顺序执行,无论之前的命令是否成功,后续命令都会继续执行完成. 有选择的执行命令 $ which cowsay&amp;gt;/dev/null &amp;amp;&amp;amp; cowsay -f head-in ohch~ 你如果没有安装cowsay，你可以先执行一次上述命令，你会发现什么也没发生，你再安装好之后你再执行一次上述命令，你也会发现一些惊喜。
上面的&amp;amp;&amp;amp;就是用来实现选择性执行的，它表示如果前面的命令执行结果（不是表示终端输出的内容，而是表示命令执行状态的结果）返回 0 则执行后面的，否则不执行，你可以从$?环境变量获取上一次命令的返回结果：
学习过 C 语言的用户应该知道在 C 语言里面&amp;amp;&amp;amp;表示逻辑与，而且还有一个||表示逻辑或，同样 Shell 也有一个||，它们的区别就在于，shell 中的这两个符号除了也可用于表示逻辑与和或之外，就是可以实现这里的命令执行顺序的简单控制。||在这里就是与&amp;amp;&amp;amp;相反的控制效果，当上一条命令执行结果为 ≠0($?≠0)时则执行它后面的命令：
$ which cowsay&amp;gt;/dev/null || echo &amp;quot;cowsay has not been install, please run &#39;sudo apt-get install cowsay&#39; to install&amp;quot; 除了上述基本的使用之外，我们还可以结合着&amp;amp;&amp;amp;和||来实现一些操作，比如：
$ which cowsay&amp;gt;/dev/null &amp;amp;&amp;amp; echo &amp;quot;exist&amp;quot; || echo &amp;quot;not exist&amp;quot; 我画个流程图来解释一下上面的流程： 管道| ls -al /etc | less 通过管道将前一个命令(ls)的输出作为下一个命令(less)的输入，然后就可以一行一行地看。</description>
    </item>
    
    <item>
      <title>dpkg</title>
      <link>http://example.org/posts/dpkg/</link>
      <pubDate>Mon, 11 May 2020 12:57:00 +0000</pubDate>
      
      <guid>http://example.org/posts/dpkg/</guid>
      <description>dpkg 介绍  dpkg 是 Debian 软件包管理器的基础，它被伊恩·默多克创建于 1993 年。dpkg 与 RPM 十分相似，同样被用于安装、卸载和供给和 .deb 软件包相关的信息。
  dpkg 本身是一个底层的工具。上层的工具，像是 APT，被用于从远程获取软件包以及处理复杂的软件包关系。&amp;ldquo;dpkg&amp;quot;是&amp;quot;Debian Package&amp;quot;的简写。
 我们经常可以在网络上见到以deb形式打包的软件包，就需要使用dpkg命令来安装。
dpkg常用参数介绍：
   参数 说明     -i 安装指定 deb 包   -R 后面加上目录名，用于安装该目录下的所有 deb 安装包   -r remove，移除某个已安装的软件包   -I 显示deb包文件的信息   -s 显示已安装软件的信息   -S 搜索已安装的软件包   -L 显示已安装软件包的目录信息    安装 我们先使用apt-get加上-d参数只下载不安装，下载 emacs 编辑器的 deb 包：</description>
    </item>
    
    <item>
      <title>编译安装</title>
      <link>http://example.org/posts/%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/</link>
      <pubDate>Fri, 08 May 2020 14:22:30 +0000</pubDate>
      
      <guid>http://example.org/posts/%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/</guid>
      <description>编译安装 准备工作  那么，要如何才能从源代码安装软件呢？首先，你必须要做好为编译源代码所需的准备工作。这包括两个方面：
  编译工具：要将源代码编译成可执行的二进制文件，编译工具必不可少： gcc , g++ , make , autoconfig 等等。在CentOS系列中，可以通过 yum -y groupinstall &amp;ldquo;Development Tools&amp;rdquo; 来安装。在 Ubuntu 中，可以从终端中执行 sudo apt-get install build-essential 指令来安装基本的编译工具。根据所编译程序的实际情况，你也可能需要安装其他一些工具。
  编译依赖：除了安装基本的编译工具之外，为了顺利编译源代码，我们也要把该程序所需要的依赖安装好。包含系统提供的库函数， 以及第三方软件的依赖包。在CentOS系列中，可以通过 yum -y install xxxx xxxx-devel 来安装相应的依赖包。Ubuntu 系统可以通过 sudo apt-get build-dep命令后跟包名的方式来准备所需的依赖。一般情况下，如果 configure 或者 make 报错，其报错信息都明确的指出缺少依赖，只需按要求做即可。或者把错误信息复制到 google 一下，即可愉快的解决。
  源码安装3部曲： ./configure ; make &amp;amp;&amp;amp; make install  在编译源代码之前，你一定把软件的源码包下载到了自己的硬盘上吧。一般而言，程序源码包经常被打包成 .tar.gz 和 .tar.bz2 这两种格式。前者可用 tar zxvf *.tar.gz 来解包，后者则用 tar jxvf *.tar.bz2。通常情况建议解压到 /usr/local/src 目录： # tar xf *.</description>
    </item>
    
    <item>
      <title>Linux命令-文件、磁盘管理</title>
      <link>http://example.org/posts/linux%E5%91%BD%E4%BB%A4-%E6%96%87%E4%BB%B6%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86-2/</link>
      <pubDate>Thu, 30 Apr 2020 12:18:53 +0000</pubDate>
      
      <guid>http://example.org/posts/linux%E5%91%BD%E4%BB%A4-%E6%96%87%E4%BB%B6%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86-2/</guid>
      <description>Linux命令-文件、磁盘管理 文件管理 查看文件信息：ls Linux文件或者目录名称最长可以有265个字符，“.”代表当前目录，“..”代表上一级目录，以“.”开头的文件为隐藏文件，需要用 -a 参数才能显示。
ls常用参数：
   参数 含义     -a 显示指定目录下所有子目录与文件，包括隐藏文件   -l 以列表方式显示文件的详细信息   -h 配合 -l 以人性化的方式显示文件大小    图中列出的信息含义如下图所示：    通配符 含义     * 文件代表文件名中所有字符   ls te* 查找以te开头的文件   ls *html 查找结尾为html的文件   ? 代表文件名中任意一个字符   ls ?.c 只找第一个字符任意，后缀为.c的文件   ls a.? 只找只有3个字符，前2字符为a.，最后一个字符任意的文件   [] [”和“]”将字符组括起来，表示可以匹配字符组中的任意一个。“-”用于表示字符范围。   [abc] 匹配a、b、c中的任意一个   [a-f] 匹配从a到f范围内的的任意一个字符   ls [a-f]* 找到从a到f范围内的的任意一个字符开头的文件   ls a-f 查找文件名为a-f的文件,当“-”处于方括号之外失去通配符的作用   \ 如果要使通配符作为普通字符使用，可以在其前面加上转义字符。“?</description>
    </item>
    
  </channel>
</rss>